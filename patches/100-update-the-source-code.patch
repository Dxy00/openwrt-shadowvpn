diff -uNr a/configure.ac b/configure.ac
--- a/configure.ac	Mon Oct  6 21:38:00 2014
+++ b/configure.ac	Wed Oct  8 10:02:10 2014
@@ -21,7 +21,25 @@
 AC_HEADER_RESOLV
 AC_CHECK_HEADERS([arpa/inet.h fcntl.h netdb.h stdlib.h string.h sys/socket.h unistd.h])
 
-AC_CHECK_HEADER([linux/if_tun.h],[],[AC_MSG_ERROR([linux/if_tun.h not found.])],[])
+# from OpenVPN configure.ac
+case "$host" in
+    *-*-linux*)
+        AC_DEFINE([TARGET_LINUX], [1], [Are we running on Linux?])
+        AC_CHECK_HEADER([linux/if_tun.h],[],[AC_MSG_ERROR([linux/if_tun.h not found.])],[])
+        ;;
+    *-*-darwin*)
+        AC_DEFINE([TARGET_DARWIN], [1], [Are we running on Mac OS X?])
+        AC_CHECK_HEADER([net/if_tun.h],[],[AC_MSG_ERROR([Mac OS X net/if_tun.h not found.])],[])
+        ;;
+    *-*-freebsd*)
+        AC_DEFINE([TARGET_FREEBSD], [1], [Are we running on FreeBSD?])
+        AC_CHECK_HEADER([net/if_tun.h],[],[AC_MSG_ERROR([FreeBSD net/if_tun.h not found.])],[])
+        ;;
+    *)
+        AC_DEFINE([TARGET_UNKNOWN], [1], [Unknown platform ?])
+esac
+
+AC_CHECK_HEADER([android/log.h],[CFLAGS="$CFLAGS -DHAVE_ANDROID_LOG"; LDFLAGS="$LDFLAGS -llog"],[],[])
 
 # Checks for typedefs, structures, and compiler characteristics.
 AC_TYPE_SIZE_T
diff -uNr a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am	Fri Oct  3 15:04:12 2014
+++ b/src/Makefile.am	Tue Oct  7 09:35:22 2014
@@ -1,10 +1,12 @@
 bin_PROGRAMS = shadowvpn
 
+lib_LTLIBRARIES = libshadowvpn.la
+
 SUBDIRS = ../libsodium
 
 AM_CFLAGS = -I$(srcdir)/../libsodium/src/libsodium/include
 
-shadowvpn_SOURCES = log.c \
+libshadowvpn_la_SOURCES = log.c \
 	log.h \
 	crypto_secretbox_salsa208poly1305.h \
 	crypto_secretbox_salsa208poly1305.c \
@@ -18,7 +20,10 @@
 	args.c \
 	daemon.h \
 	daemon.c \
-	shadowvpn.h \
-	main.c
-shadowvpn_LDADD = ../libsodium/src/libsodium/libsodium.la
+	shadowvpn.h
+libshadowvpn_la_LIBADD = ../libsodium/src/libsodium/libsodium.la
+
+shadowvpn_SOURCES = main.c
+
+shadowvpn_LDADD = libshadowvpn.la
 
diff -uNr a/src/log.h b/src/log.h
--- a/src/log.h	Fri Oct  3 14:17:36 2014
+++ b/src/log.h	Wed Oct  8 10:02:10 2014
@@ -28,7 +28,7 @@
 
 #include <string.h>
 #include <stdio.h>
-#include "config.h"
+#include <errno.h>
 
 extern int verbose_mode;
 
@@ -41,9 +41,24 @@
   }                                                               \
 } while (0)
 
+#ifdef HAVE_ANDROID_LOG
+#include <android/log.h>
+#define logf(s...) \
+      __android_log_print(ANDROID_LOG_INFO, __FILE__, s)
+
+#define errf(s...) \
+      __android_log_print(ANDROID_LOG_ERROR, __FILE__, s)
+
+#define err(s) \
+      __android_log_print(ANDROID_LOG_ERROR, __FILE__, "%s: %s", s, strerror(errno))
+
+#else
+
 #define logf(s...) __LOG(stdout, 0, s)
 #define errf(s...) __LOG(stderr, 1, s)
 #define err(s) perror_timestamp(s, __FILE__, __LINE__)
+
+#endif
 
 #ifdef DEBUG
 #define debugf(s...) logf(s)
diff -uNr a/src/main.c b/src/main.c
--- a/src/main.c	Fri Oct  3 14:31:12 2014
+++ b/src/main.c	Tue Oct  7 09:35:22 2014
@@ -29,11 +29,13 @@
 #include <signal.h>
 #include "shadowvpn.h"
 
+static vpn_ctx_t vpn_ctx;
+
 static void sig_handler(int signo) {
   if (signo == SIGINT)
     exit(1);  // for gprof
   else
-    stop_vpn();
+    vpn_stop(&vpn_ctx);
 }
 
 int main(int argc, char **argv) {
@@ -79,5 +81,8 @@
   signal(SIGINT, sig_handler);
   signal(SIGTERM, sig_handler);
 
-  return run_vpn(&args);;
+  if (-1 == vpn_ctx_init(&vpn_ctx, &args)) {
+    return EXIT_FAILURE;
+  }
+  return vpn_run(&vpn_ctx);
 }
diff -uNr a/src/shadowvpn.h b/src/shadowvpn.h
--- a/src/shadowvpn.h	Thu Sep 25 01:13:08 2014
+++ b/src/shadowvpn.h	Wed Oct  8 10:02:10 2014
@@ -26,6 +26,10 @@
 #ifndef SHADOWVPN_H
 #define SHADOWVPN_H
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include "log.h"
 #include "crypto.h"
 #include "args.h"
diff -uNr a/src/shell.c b/src/shell.c
--- a/src/shell.c	Fri Oct  3 17:02:26 2014
+++ b/src/shell.c	Tue Oct  7 09:35:22 2014
@@ -47,6 +47,10 @@
   } else {
     script = args->down_script;
   }
+  if (script == NULL || script[0] == 0) {
+    errf("warning: script not set");
+    return 0;
+  }
   buf = malloc(strlen(script) + 8);
   sprintf(buf, "sh %s", script);
   logf("executing %s", script);
diff -uNr a/src/vpn.c b/src/vpn.c
--- a/src/vpn.c	Sat Oct  4 17:42:54 2014
+++ b/src/vpn.c	Wed Oct  8 10:02:10 2014
@@ -23,6 +23,8 @@
 
 */
 
+#include "shadowvpn.h"
+
 #include <sys/types.h>
 #include <sys/select.h>
 #include <stdio.h>
@@ -31,26 +33,30 @@
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <fcntl.h>
-#include <sys/socket.h>
 #include <netdb.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <net/if.h>
-#include <linux/if_tun.h>
-#include "shadowvpn.h"
 
-static int running = 0;
-static int control_pipe[2];
+#ifdef TARGET_DARWIN
+#include <sys/kern_control.h>
+#include <net/if_utun.h>
+#include <sys/sys_domain.h>
+#endif
 
-static int tun_alloc(const char *dev);
+#ifdef TARGET_LINUX
+#include <linux/if_tun.h>
+#endif
 
-static int udp_alloc(int if_bind, const char *host, int port,
-                     struct sockaddr *addr, socklen_t* addrlen);
+#ifdef TARGET_FREEBSD
+#include <net/if_tun.h>
+#endif
 
 
-static int tun_alloc(const char *dev) {
+#ifdef TARGET_LINUX
+int vpn_tun_alloc(const char *dev) {
   struct ifreq ifr;
-  int fd, err;
+  int fd, e;
 
   if ((fd = open("/dev/net/tun", O_RDWR)) < 0) {
     err("open");
@@ -60,17 +66,17 @@
 
   memset(&ifr, 0, sizeof(ifr));
 
-  /* Flags: IFF_TUN   - TUN device (no Ethernet headers) 
-   *        IFF_TAP   - TAP device  
+  /* Flags: IFF_TUN   - TUN device (no Ethernet headers)
+   *        IFF_TAP   - TAP device
    *
-   *        IFF_NO_PI - Do not provide packet information  
-   */ 
-  ifr.ifr_flags = IFF_TUN | IFF_NO_PI; 
+   *        IFF_NO_PI - Do not provide packet information
+   */
+  ifr.ifr_flags = IFF_TUN | IFF_NO_PI;
   if(*dev)
     strncpy(ifr.ifr_name, dev, IFNAMSIZ);
 
-  if((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0){
-    err("ioctl");
+  if ((e = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0) {
+    err("ioctl[TUNSETIFF]");
     errf("can not setup tun device: %s", dev);
     close(fd);
     return -1;
@@ -78,9 +84,38 @@
   // strcpy(dev, ifr.ifr_name);
   return fd;
 }
+#endif
+
+#ifdef TARGET_FREEBSD
+int vpn_tun_alloc(const char *dev) {
+  int fd;
+  char devname[32]={0,};
+  snprintf(devname, sizeof(devname), "/dev/%s", dev);
+  if ((fd = open(devname, O_RDWR)) < 0) {
+    err("open");
+    errf("can not open %s", devname);
+    return -1;
+  }
+  int i = IFF_POINTOPOINT | IFF_MULTICAST;
+  if (ioctl(fd, TUNSIFMODE, &i) < 0) {
+    err("ioctl[TUNSIFMODE]");
+    errf("can not setup tun device: %s", dev);
+    close(fd);
+    return -1;
+  }
+  i = 0;
+  if (ioctl(fd, TUNSIFHEAD, &i) < 0) {
+    err("ioctl[TUNSIFHEAD]");
+    errf("can not setup tun device: %s", dev);
+    close(fd);
+    return -1;
+  }
+  return fd;
+}
+#endif
 
-static int udp_alloc(int if_bind, const char *host, int port,
-                     struct sockaddr *addr, socklen_t* addrlen) {
+int vpn_udp_alloc(int if_bind, const char *host, int port,
+                  struct sockaddr *addr, socklen_t* addrlen) {
   struct addrinfo hints;
   struct addrinfo *res;
   int sock, r, flags;
@@ -90,7 +125,7 @@
   hints.ai_protocol = IPPROTO_UDP;
   if (0 != (r = getaddrinfo(host, NULL, &hints, &res))) {
     errf("getaddrinfo: %s", gai_strerror(r));
-    return -1; 
+    return -1;
   }
 
   if (res->ai_family == AF_INET)
@@ -101,7 +136,7 @@
     errf("unknown ai_family %d", res->ai_family);
     return -1;
   }
-  memcpy(addr, res->ai_addr, res->ai_addrlen); 
+  memcpy(addr, res->ai_addr, res->ai_addrlen);
   *addrlen = res->ai_addrlen;
 
   if (-1 == (sock = socket(res->ai_family, SOCK_DGRAM, IPPROTO_UDP))) {
@@ -114,7 +149,7 @@
     if (0 != bind(sock, res->ai_addr, res->ai_addrlen)) {
       err("bind");
       errf("can not bind %s:%d", host, port);
-      return -1; 
+      return -1;
     }
     freeaddrinfo(res);
   }
@@ -128,62 +163,63 @@
   return -1;
 }
 
-int max(int a, int b) {
+static int max(int a, int b) {
   return a > b ? a : b;
 }
 
-int run_vpn(shadowvpn_args_t *args) {
-  fd_set readset;
-  int tun, sock, max_fd;
-  ssize_t r;
-  unsigned char *tun_buf;
-  unsigned char *udp_buf;
-  struct sockaddr_storage remote_addr;
-  struct sockaddr *remote_addrp = (struct sockaddr *)&remote_addr;
-  socklen_t remote_addrlen;
+int vpn_ctx_init(vpn_ctx_t *ctx, shadowvpn_args_t *args) {
+  bzero(ctx, sizeof(vpn_ctx_t));
+  ctx->remote_addrp = (struct sockaddr *)&ctx->remote_addr;
 
-  if (running) {
-    errf("can not start, already running");
-    return -1;
-  }
-
-  if (-1 == pipe(control_pipe)) {
+  if (-1 == pipe(ctx->control_pipe)) {
     err("pipe");
     return -1;
   }
-
-  if (-1 == (tun = tun_alloc(args->intf))) {
+  if (-1 == (ctx->tun = vpn_tun_alloc(args->intf))) {
     errf("failed to create tun device");
     return -1;
   }
-  if (-1 == (sock = udp_alloc(args->mode == SHADOWVPN_MODE_SERVER,
-                              args->server, args->port,
-                              remote_addrp, &remote_addrlen))) {
+  if (-1 == (ctx->sock = vpn_udp_alloc(args->mode == SHADOWVPN_MODE_SERVER,
+                                       args->server, args->port,
+                                       ctx->remote_addrp,
+                                       &ctx->remote_addrlen))) {
     errf("failed to create UDP socket");
-    close(tun);
+    close(ctx->tun);
+    return -1;
+  }
+  ctx->args = args;
+  return 0;
+}
+
+int vpn_run(vpn_ctx_t *ctx) {
+  fd_set readset;
+  int max_fd;
+  ssize_t r;
+  if (ctx->running) {
+    errf("can not start, already running");
     return -1;
   }
 
-  running = 1;
+  ctx->running = 1;
 
-  shell_up(args);
+  shell_up(ctx->args);
 
-  tun_buf = malloc(args->mtu + SHADOWVPN_ZERO_BYTES);
-  udp_buf = malloc(args->mtu + SHADOWVPN_ZERO_BYTES);
-  memset(tun_buf, 0, SHADOWVPN_ZERO_BYTES);
-  memset(udp_buf, 0, SHADOWVPN_ZERO_BYTES);
+  ctx->tun_buf = malloc(ctx->args->mtu + SHADOWVPN_ZERO_BYTES);
+  ctx->udp_buf = malloc(ctx->args->mtu + SHADOWVPN_ZERO_BYTES);
+  bzero(ctx->tun_buf, SHADOWVPN_ZERO_BYTES);
+  bzero(ctx->udp_buf, SHADOWVPN_ZERO_BYTES);
 
   logf("VPN started");
 
-  while (running) {
+  while (ctx->running) {
     FD_ZERO(&readset);
-    FD_SET(control_pipe[0], &readset);
-    FD_SET(tun, &readset);
-    FD_SET(sock, &readset);
+    FD_SET(ctx->control_pipe[0], &readset);
+    FD_SET(ctx->tun, &readset);
+    FD_SET(ctx->sock, &readset);
 
     // we assume that pipe fd is always less than tun and sock fd which are
     // created later
-    max_fd = max(tun, sock) + 1;
+    max_fd = max(ctx->tun, ctx->sock) + 1;
 
     if (-1 == select(max_fd, &readset, NULL, NULL, NULL)) {
       if (errno == EINTR)
@@ -191,13 +227,13 @@
       err("select");
       break;
     }
-    if (FD_ISSET(control_pipe[0], &readset)) {
+    if (FD_ISSET(ctx->control_pipe[0], &readset)) {
       char pipe_buf;
-      (void)read(control_pipe[0], &pipe_buf, 1);
+      (void)read(ctx->control_pipe[0], &pipe_buf, 1);
       break;
     }
-    if (FD_ISSET(tun, &readset)) {
-      r = read(tun, tun_buf + SHADOWVPN_ZERO_BYTES, args->mtu); 
+    if (FD_ISSET(ctx->tun, &readset)) {
+      r = read(ctx->tun, ctx->tun_buf + SHADOWVPN_ZERO_BYTES, ctx->args->mtu); 
       if (r == -1) {
         if (errno == EAGAIN || errno == EWOULDBLOCK) {
           // do nothing
@@ -209,11 +245,11 @@
           break;
         }
       }
-      if (remote_addrlen) {
-        crypto_encrypt(udp_buf, tun_buf, r);
-        r = sendto(sock, udp_buf + SHADOWVPN_PACKET_OFFSET,
+      if (ctx->remote_addrlen) {
+        crypto_encrypt(ctx->udp_buf, ctx->tun_buf, r);
+        r = sendto(ctx->sock, ctx->udp_buf + SHADOWVPN_PACKET_OFFSET,
                    SHADOWVPN_OVERHEAD_LEN + r, 0,
-                   remote_addrp, remote_addrlen);
+                   ctx->remote_addrp, ctx->remote_addrlen);
         if (r == -1) {
           if (errno == EAGAIN || errno == EWOULDBLOCK) {
             // do nothing
@@ -229,19 +265,19 @@
         }
       }
     }
-    if (FD_ISSET(sock, &readset)) {
+    if (FD_ISSET(ctx->sock, &readset)) {
       // only change remote addr if decryption succeeds
       struct sockaddr_storage temp_remote_addr;
       socklen_t temp_remote_addrlen = sizeof(temp_remote_addr);
-      r = recvfrom(sock, udp_buf + SHADOWVPN_PACKET_OFFSET,
-                   SHADOWVPN_OVERHEAD_LEN + args->mtu, 0,
+      r = recvfrom(ctx->sock, ctx->udp_buf + SHADOWVPN_PACKET_OFFSET,
+                   SHADOWVPN_OVERHEAD_LEN + ctx->args->mtu, 0,
                    (struct sockaddr *)&temp_remote_addr,
                    &temp_remote_addrlen);
       if (r == -1) {
         if (errno == EAGAIN || errno == EWOULDBLOCK) {
           // do nothing
         } else if (errno == ENETUNREACH || errno == ENETDOWN ||
-                    errno == EPERM || errno == EINTR) {
+                   errno == EPERM || errno == EINTR) {
           // just log, do nothing
           err("recvfrom");
         } else {
@@ -253,17 +289,17 @@
       if (r == 0)
         continue;
 
-      if (-1 == crypto_decrypt(tun_buf, udp_buf,
+      if (-1 == crypto_decrypt(ctx->tun_buf, ctx->udp_buf,
                                r - SHADOWVPN_OVERHEAD_LEN)) {
         errf("dropping invalid packet, maybe wrong password");
       } else {
-        if (args->mode == SHADOWVPN_MODE_SERVER) {
+        if (ctx->args->mode == SHADOWVPN_MODE_SERVER) {
           // if we are running a server, update server address from recv_from
-          memcpy(remote_addrp, &temp_remote_addr, temp_remote_addrlen);
-          remote_addrlen = temp_remote_addrlen;
+          memcpy(ctx->remote_addrp, &temp_remote_addr, temp_remote_addrlen);
+          ctx->remote_addrlen = temp_remote_addrlen;
         }
 
-        if (-1 == write(tun, tun_buf + SHADOWVPN_ZERO_BYTES,
+        if (-1 == write(ctx->tun, ctx->tun_buf + SHADOWVPN_ZERO_BYTES,
               r - SHADOWVPN_OVERHEAD_LEN)) {
           if (errno == EAGAIN || errno == EWOULDBLOCK) {
             // do nothing
@@ -278,30 +314,29 @@
       }
     }
   }
-  free(tun_buf);
-  free(udp_buf);
+  free(ctx->tun_buf);
+  free(ctx->udp_buf);
 
-  shell_down(args);
+  shell_down(ctx->args);
 
-  close(tun);
-  close(sock);
+  close(ctx->tun);
+  close(ctx->sock);
 
-  running = 0;
+  ctx->running = 0;
   return -1;
 }
 
-int stop_vpn() {
+int vpn_stop(vpn_ctx_t *ctx) {
   logf("shutting down by user");
-  if (!running) {
+  if (!ctx->running) {
     errf("can not stop, not running");
     return -1;
   }
-  running = 0;
+  ctx->running = 0;
   char buf = 0;
-  if (-1 == write(control_pipe[1], &buf, 1)) {
+  if (-1 == write(ctx->control_pipe[1], &buf, 1)) {
     err("write");
     return -1;
   }
   return 0;
 }
-
diff -uNr a/src/vpn.h b/src/vpn.h
--- a/src/vpn.h	Fri Oct  3 14:26:04 2014
+++ b/src/vpn.h	Wed Oct  8 10:02:10 2014
@@ -26,10 +26,33 @@
 #ifndef VPN_H
 #define VPN_H
 
+#include <sys/socket.h>
 #include "args.h"
 
-int run_vpn(shadowvpn_args_t *args);
+typedef struct {
+  int running;
+  int sock;
+  int tun;
+  int control_pipe[2];
+  unsigned char *tun_buf;
+  unsigned char *udp_buf;
+  struct sockaddr_storage remote_addr;
+  struct sockaddr *remote_addrp;
+  socklen_t remote_addrlen;
+  shadowvpn_args_t *args;
+} vpn_ctx_t;
 
-int stop_vpn();
+int vpn_tun_alloc(const char *dev);
+int vpn_udp_alloc(int if_bind, const char *host, int port,
+                  struct sockaddr *addr, socklen_t* addrlen);
+
+/* return -1 on error. no need to destroy any resource */
+int vpn_ctx_init(vpn_ctx_t *ctx, shadowvpn_args_t *args);
+
+/* return -1 on error. no need to destroy any resource */
+int vpn_run(vpn_ctx_t *ctx);
+
+/* return -1 on error. no need to destroy any resource */
+int vpn_stop(vpn_ctx_t *ctx);
 
 #endif
