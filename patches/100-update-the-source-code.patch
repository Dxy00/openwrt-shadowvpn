diff -uNr a/src/daemon.c b/src/daemon.c
--- a/src/daemon.c	Fri Oct  3 16:51:56 2014
+++ b/src/daemon.c	Sun Oct  5 12:42:10 2014
@@ -27,6 +27,8 @@
 #include <signal.h>
 #include <unistd.h>
 #include <fcntl.h>
+#include <errno.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include "shadowvpn.h"
 
@@ -34,6 +36,10 @@
 
 static int write_pid_file(const char *filename, pid_t pid);
 
+static void sig_handler_exit(int signo) {
+  exit(0);
+}
+
 int daemon_start(const shadowvpn_args_t *args) {
   pid_t pid = fork();
   if (pid == -1) {
@@ -42,16 +48,21 @@
   }
   if (pid > 0) {
     // let the child print message to the console first
-    usleep(300);
+    signal(SIGINT, sig_handler_exit);
+    sleep(5);
     exit(0);
   } 
 
+  pid_t ppid = getppid();
   pid = getpid();
-  if (0 != write_pid_file(args->pid_file, pid))
+  if (0 != write_pid_file(args->pid_file, pid)) {
+    kill(ppid, SIGINT);
     return -1;
+  }
 
   // print on console
   printf("started\n");
+  kill(ppid, SIGINT);
 
   // then rediret stdout & stderr
   fclose(stdin);
@@ -119,22 +130,43 @@
 
 int daemon_stop(const shadowvpn_args_t *args) {
   char buf[PID_BUF_SIZE];
+  int status, i, stopped;
   FILE *fp = fopen(args->pid_file, "r");
   if (fp == NULL) {
-    errf("not started");
-    return -1;
+    printf("not running\n");
+    return 0;
   }
   char *line = fgets(buf, PID_BUF_SIZE, fp);
   fclose(fp);
   if (line == NULL) {
     err("fgets");
-    return -1;
+    return 0;
   }
   pid_t pid = (pid_t)atol(buf);
   if (pid > 0) {
     // make sure pid is not zero or negative
     if (0 != kill(pid, SIGTERM)){
+      if (errno == ESRCH) {
+        printf("not running\n");
+        return 0;
+      }
       err("kill");
+      return -1;
+    }
+    stopped = 0;
+    // wait for maximum 10s
+    for (i = 0; i < 200; i++) {
+      if (-1 == kill(pid, 0)) {
+        if (errno == ESRCH) {
+          stopped = 1;
+          break;
+        }
+      }
+      // sleep 0.05s
+      usleep(50000);
+    }
+    if (!stopped) {
+      errf("timed out when stopping pid %d", pid);
       return -1;
     }
     printf("stopped\n");
diff -uNr a/src/vpn.c b/src/vpn.c
--- a/src/vpn.c	Fri Oct  3 14:58:44 2014
+++ b/src/vpn.c	Sun Oct  5 12:42:10 2014
@@ -141,8 +141,6 @@
   struct sockaddr_storage remote_addr;
   struct sockaddr *remote_addrp = (struct sockaddr *)&remote_addr;
   socklen_t remote_addrlen;
-  struct sockaddr *src_addrp = NULL;
-  socklen_t *src_addrlen = NULL;
 
   if (running) {
     errf("can not start, already running");
@@ -154,12 +152,6 @@
     return -1;
   }
 
-  if (args->mode == SHADOWVPN_MODE_SERVER) {
-    // if we are running a server, update server address from recv_from
-    src_addrp = remote_addrp;
-    src_addrlen = &remote_addrlen;
-  }
-
   if (-1 == (tun = tun_alloc(args->intf))) {
     errf("failed to create tun device");
     return -1;
@@ -201,7 +193,7 @@
     }
     if (FD_ISSET(control_pipe[0], &readset)) {
       char pipe_buf;
-      read(control_pipe[0], &pipe_buf, 1);
+      (void)read(control_pipe[0], &pipe_buf, 1);
       break;
     }
     if (FD_ISSET(tun, &readset)) {
@@ -238,9 +230,13 @@
       }
     }
     if (FD_ISSET(sock, &readset)) {
+      // only change remote addr if decryption succeeds
+      struct sockaddr_storage temp_remote_addr;
+      socklen_t temp_remote_addrlen = sizeof(temp_remote_addr);
       r = recvfrom(sock, udp_buf + SHADOWVPN_PACKET_OFFSET,
                    SHADOWVPN_OVERHEAD_LEN + args->mtu, 0,
-                   src_addrp, src_addrlen);
+                   (struct sockaddr *)&temp_remote_addr,
+                   &temp_remote_addrlen);
       if (r == -1) {
         if (errno == EAGAIN || errno == EWOULDBLOCK) {
           // do nothing
@@ -254,10 +250,19 @@
           break;
         }
       }
+      if (r == 0)
+        continue;
 
-      if (-1 == crypto_decrypt(tun_buf, udp_buf, r - SHADOWVPN_OVERHEAD_LEN)) {
-        errf("invalid packet, drop");
+      if (-1 == crypto_decrypt(tun_buf, udp_buf,
+                               r - SHADOWVPN_OVERHEAD_LEN)) {
+        errf("dropping invalid packet, maybe wrong password");
       } else {
+        if (args->mode == SHADOWVPN_MODE_SERVER) {
+          // if we are running a server, update server address from recv_from
+          memcpy(remote_addrp, &temp_remote_addr, temp_remote_addrlen);
+          remote_addrlen = temp_remote_addrlen;
+        }
+
         if (-1 == write(tun, tun_buf + SHADOWVPN_ZERO_BYTES,
               r - SHADOWVPN_OVERHEAD_LEN)) {
           if (errno == EAGAIN || errno == EWOULDBLOCK) {
